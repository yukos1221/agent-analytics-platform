/**
 * Migration Runner for Drizzle ORM
 *
 * Implements migration management as per docs/05-development-deployment-v1.2.md Section 12.
 *
 * Phase 1: Manual migrations (this script)
 * Phase 2: Automated migrations in CI
 *
 * Usage:
 *   - Run migrations: pnpm db:migrate
 *   - Rollback: pnpm db:rollback --steps 1
 *   - Status: pnpm db:migrate:status
 */

import { drizzle } from 'drizzle-orm/postgres-js';
import { migrate as drizzleMigrate } from 'drizzle-orm/postgres-js/migrator';
import { sql } from 'drizzle-orm';
import postgres from 'postgres';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface MigrationOptions {
	direction?: 'up' | 'down';
	dryRun?: boolean;
	steps?: number;
	target?: string;
}

interface MigrationResult {
	success: boolean;
	migrations: string[];
	duration?: number;
	dryRun?: boolean;
	error?: string;
}

interface MigrationFile {
	id: string;
	description: string;
	path: string;
}

/**
 * Get database connection
 */
function getDb() {
	const connectionString = process.env.DATABASE_URL;
	if (!connectionString) {
		throw new Error('DATABASE_URL environment variable is required');
	}
	const sql = postgres(connectionString, { max: 1 });
	return { db: drizzle(sql), sql };
}

/**
 * Load migration files from src/migrations directory
 */
function getMigrationFiles(): MigrationFile[] {
	const migrationsDir = path.join(__dirname, 'migrations');
	if (!fs.existsSync(migrationsDir)) {
		return [];
	}

	const files = fs
		.readdirSync(migrationsDir)
		.filter((f) => f.endsWith('.ts') && !f.endsWith('.test.ts'))
		.sort();

	return files.map((file) => {
		const filePath = path.join(migrationsDir, file);
		// Try to extract id and description from the file
		// For now, use filename as id
		const id = file.replace('.ts', '');
		return {
			id,
			description: `Migration ${id}`,
			path: filePath,
		};
	});
}

/**
 * Get applied migrations from drizzle_migrations table
 */
async function getAppliedMigrations(
	db: ReturnType<typeof drizzle>
): Promise<string[]> {
	try {
		const result = await db.execute<{ hash: string; created_at: Date }>(sql`
			SELECT hash FROM drizzle_migrations ORDER BY created_at ASC
		`);
		return result.map((r) => r.hash);
	} catch (error) {
		// Table doesn't exist yet - no migrations applied
		if ((error as { code?: string }).code === '42P01') {
			return [];
		}
		throw error;
	}
}

/**
 * Run migrations UP (apply pending migrations)
 */
export async function runMigrations(
	options: MigrationOptions = { direction: 'up' }
): Promise<MigrationResult> {
	const startTime = Date.now();
	const { db, sql } = getDb();

	try {
		if (options.direction === 'down') {
			throw new Error(
				'Use rollbackMigrations() for rollback. This function only runs migrations UP.'
			);
		}

		if (options.dryRun) {
			const applied = await getAppliedMigrations(db);
			const allMigrations = getMigrationFiles();
			const pending = allMigrations
				.filter((m) => !applied.includes(m.id))
				.map((m) => m.id);

			return {
				success: true,
				migrations: pending,
				dryRun: true,
			};
		}

		// Use Drizzle's built-in migrator
		// It reads from migrations/ folder (SQL files generated by drizzle-kit generate)
		// migrations/ folder is at package root (packages/database/migrations)
		const packageRoot = path.resolve(__dirname, '..');
		const migrationsFolder = path.join(packageRoot, 'migrations');

		if (!fs.existsSync(migrationsFolder)) {
			throw new Error(
				`Migrations folder not found: ${migrationsFolder}. ` +
					`Run 'pnpm db:generate' first to generate migrations.`
			);
		}

		// Ensure meta/_journal.json exists (required by Drizzle migrator)
		const metaDir = path.join(migrationsFolder, 'meta');
		const journalPath = path.join(metaDir, '_journal.json');
		if (!fs.existsSync(journalPath)) {
			// Create meta directory if it doesn't exist
			if (!fs.existsSync(metaDir)) {
				fs.mkdirSync(metaDir, { recursive: true });
			}
			// Create a basic journal file if it doesn't exist
			// This is a fallback - ideally migrations should be generated with drizzle-kit generate
			const journalContent = {
				version: '7',
				dialect: 'postgresql',
				entries: [
					{
						idx: 0,
						version: '7',
						when: Date.now(),
						tag: '001_init',
						breakpoints: true,
					},
				],
			};
			fs.writeFileSync(journalPath, JSON.stringify(journalContent, null, 2));
			console.log(
				'⚠️  Created meta/_journal.json. Consider running `pnpm db:generate` to generate proper migration metadata.'
			);
		}

		await drizzleMigrate(db, { migrationsFolder });

		const duration = Date.now() - startTime;
		return {
			success: true,
			migrations: [],
			duration,
		};
	} catch (error) {
		const err = error as Error;
		// Provide more detailed error information
		let errorMessage = err.message || String(error);

		// Handle AggregateError (common with postgres connection errors)
		if (error instanceof Error && 'errors' in error) {
			const aggregateError = error as { errors: unknown[] };
			const firstError = aggregateError.errors?.[0];
			if (firstError instanceof Error) {
				errorMessage = firstError.message || errorMessage;
			}
		}

		// Handle cause chain
		if ((err as { cause?: Error }).cause) {
			const cause = (err as { cause: Error }).cause;
			errorMessage = `${errorMessage}: ${cause.message}`;
		}

		return {
			success: false,
			migrations: [],
			error: errorMessage,
		};
	} finally {
		await sql.end();
	}
}

/**
 * Get migration status
 */
export async function getMigrationStatus(): Promise<{
	applied: string[];
	pending: string[];
	total: number;
}> {
	const { db, sql } = getDb();

	try {
		const applied = await getAppliedMigrations(db);
		const allMigrations = getMigrationFiles();
		const pending = allMigrations
			.filter((m) => !applied.includes(m.id))
			.map((m) => m.id);

		return {
			applied,
			pending,
			total: allMigrations.length,
		};
	} finally {
		await sql.end();
	}
}
