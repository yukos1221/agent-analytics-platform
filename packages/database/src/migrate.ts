/**
 * Migration Runner for Drizzle ORM
 *
 * Implements migration management as per docs/05-development-deployment-v1.2.md Section 12.
 *
 * Phase 1: Manual migrations (this script)
 * Phase 2: Automated migrations in CI
 *
 * Usage:
 *   - Run migrations: pnpm db:migrate
 *   - Rollback: pnpm db:rollback --steps 1
 *   - Status: pnpm db:migrate:status
 */

import { drizzle } from 'drizzle-orm/postgres-js';
import { migrate as drizzleMigrate } from 'drizzle-orm/postgres-js/migrator';
import { sql } from 'drizzle-orm';
import postgres from 'postgres';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface MigrationOptions {
	direction?: 'up' | 'down';
	dryRun?: boolean;
	steps?: number;
	target?: string;
}

interface MigrationResult {
	success: boolean;
	migrations: string[];
	duration?: number;
	dryRun?: boolean;
	error?: string;
}

interface MigrationFile {
	id: string;
	description: string;
	path: string;
}

/**
 * Get database connection
 */
function getDb() {
	const connectionString = process.env.DATABASE_URL;
	if (!connectionString) {
		throw new Error('DATABASE_URL environment variable is required');
	}
	const sql = postgres(connectionString, { max: 1 });
	return { db: drizzle(sql), sql };
}

/**
 * Load migration files from src/migrations directory
 */
function getMigrationFiles(): MigrationFile[] {
	const migrationsDir = path.join(__dirname, 'migrations');
	if (!fs.existsSync(migrationsDir)) {
		return [];
	}

	const files = fs
		.readdirSync(migrationsDir)
		.filter((f) => f.endsWith('.ts') && !f.endsWith('.test.ts'))
		.sort();

	return files.map((file) => {
		const filePath = path.join(migrationsDir, file);
		// Try to extract id and description from the file
		// For now, use filename as id
		const id = file.replace('.ts', '');
		return {
			id,
			description: `Migration ${id}`,
			path: filePath,
		};
	});
}

/**
 * Get applied migrations from drizzle_migrations table
 */
async function getAppliedMigrations(
	db: ReturnType<typeof drizzle>
): Promise<string[]> {
	try {
		const result = await db.execute<{ hash: string; created_at: Date }>(sql`
			SELECT hash FROM drizzle_migrations ORDER BY created_at ASC
		`);
		return result.map((r) => r.hash);
	} catch (error) {
		// Table doesn't exist yet - no migrations applied
		if ((error as { code?: string }).code === '42P01') {
			return [];
		}
		throw error;
	}
}

/**
 * Run migrations UP (apply pending migrations)
 */
export async function runMigrations(
	options: MigrationOptions = { direction: 'up' }
): Promise<MigrationResult> {
	const startTime = Date.now();
	const { db, sql } = getDb();

	try {
		if (options.direction === 'down') {
			throw new Error(
				'Use rollbackMigrations() for rollback. This function only runs migrations UP.'
			);
		}

		if (options.dryRun) {
			const applied = await getAppliedMigrations(db);
			const allMigrations = getMigrationFiles();
			const pending = allMigrations
				.filter((m) => !applied.includes(m.id))
				.map((m) => m.id);

			return {
				success: true,
				migrations: pending,
				dryRun: true,
			};
		}

		// Use Drizzle's built-in migrator
		// It reads from migrations/ folder (SQL files generated by drizzle-kit generate)
		// migrations/ folder is at package root (packages/database/migrations)
		const packageRoot = path.resolve(__dirname, '..');
		const migrationsFolder = path.join(packageRoot, 'migrations');

		if (!fs.existsSync(migrationsFolder)) {
			throw new Error(
				`Migrations folder not found: ${migrationsFolder}. ` +
					`Run 'pnpm db:generate' first to generate migrations.`
			);
		}

		await drizzleMigrate(db, { migrationsFolder });

		const duration = Date.now() - startTime;
		return {
			success: true,
			migrations: [],
			duration,
		};
	} catch (error) {
		const err = error as Error;
		return {
			success: false,
			migrations: [],
			error: err.message,
		};
	} finally {
		await sql.end();
	}
}

/**
 * Get migration status
 */
export async function getMigrationStatus(): Promise<{
	applied: string[];
	pending: string[];
	total: number;
}> {
	const { db, sql } = getDb();

	try {
		const applied = await getAppliedMigrations(db);
		const allMigrations = getMigrationFiles();
		const pending = allMigrations
			.filter((m) => !applied.includes(m.id))
			.map((m) => m.id);

		return {
			applied,
			pending,
			total: allMigrations.length,
		};
	} finally {
		await sql.end();
	}
}
